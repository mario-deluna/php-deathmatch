#!/usr/bin/env php
<?php 
if (!defined('DS')) { define('DS', DIRECTORY_SEPARATOR); }
/**
 *---------------------------------------------------------------
 * Autoloader / Compser
 *---------------------------------------------------------------
 *
 * We need to access our dependencies & autloader..
 */
require __DIR__ . DS . '..' . DS . 'vendor' . DS . 'autoload.php';

/**
 * Paths
 */
define('PATH_RESOURCES', __DIR__ . DS . '..' . DS . 'resources');
define('PATH_SHADER', PATH_RESOURCES . DS . 'shader');
define('PATH_TEXUTRE', PATH_RESOURCES . DS . 'textures');

// dependencies
use PGF\{
    Window,
    Scene, 
    Shader\Manager as ShaderManager,

    Camera\PerspectiveCamera,

    System\Draw3DSystem,

    // primitives
    Entity\Primitives\Cube
};

use glm\{
    vec2, vec3, vec4,
    mat4
};

/**
 *---------------------------------------------------------------
 * Prepare and configure the window.
 *---------------------------------------------------------------
 *
 * Hints etc.
 */
$window = new Window;

// configure the window
$window->setHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
$window->setHint(GLFW_CONTEXT_VERSION_MINOR, 3);
$window->setHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
$window->setHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);

// open it
$window->open('PHP Deathmatch');

// enable vsync
$window->setSwapInterval(1);

// enable depth testing
glEnable(GL_DEPTH_TEST);

/**
 * Prepare Shaders
 */
$shaders = new ShaderManager();
foreach(['base3d'] as $shaderName) {
    $shaders->load($shaderName, 
        PATH_SHADER . '/'.$shaderName.'.vert.glsl', 
        PATH_SHADER . '/'.$shaderName.'.frag.glsl'
    );

}

/**
 * Create a camera
 */
$camera = new PerspectiveCamera(new vec3(0.0, -15.0, 0.0));

/**
 * Create a new scene
 */
$scene = new Scene;
$scene->addSystem(new Draw3DSystem($shaders->get('base3d'), $camera));

/**
 * Load the map
 */
$map = "
*****
*   *
*   *
*   *
*****
";

$gun = new Cube(new vec3(0, 0, 0), new vec3(1, 1, 1), new vec3(0, 0, 0));
$scene->entities->add($gun);

$gun2 = new Cube(new vec3(0, 0, 0), new vec3(1, 1, 1), new vec3(0, 0, 0));
$scene->entities->add($gun2);

$floor = new Cube(new vec3(0, -20, 0), new vec3(10, 0.5, 10), new vec3(0, 0, 0));
$scene->entities->add($floor);

// for($i=0;$i<1000;$i++) {
//     $cube = new Cube(new vec3(mt_rand(0, 100), mt_rand(0, 100), mt_rand(0, 100)), new vec3(mt_rand(0, 10), mt_rand(0, 10), mt_rand(0, 10)), new vec3(mt_rand(0, 90), mt_rand(0, 90), mt_rand(0, 90)));
//     $scene->entities->add($cube);
// }




/** 
 * Texture 
 */
$texture;
glGenTextures(1, $texture);
glBindTexture(GL_TEXTURE_2D, $texture); // all upcoming GL_TEXTURE_2D operations now have effect on this texture object
// set the texture wrapping parameters
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   // set texture wrapping to GL_REPEAT (default wrapping method)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
// set texture filtering parameters
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

$data = stbi_load(PATH_TEXUTRE . '/noiseb.png', $width, $height, $nrChannels, 0);
if ($data) {
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, $width, $height, 0, GL_RGB, GL_UNSIGNED_BYTE, $data);
    glGenerateMipmap(GL_TEXTURE_2D);
} else {
    die('Could not load texture.');
}

//glViewport(0, 0, 800, 600);


glfwSetInputMode($window->getContext(), GLFW_CURSOR, GLFW_CURSOR_DISABLED);  

$lx = $ly = 0;
$camera->setAngel(-90, 0);

/**
 * Main loop
 */
while (!$window->shouldClose())
{   
    $window->pollEvents();

    // bind the texture
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, $texture);

    if ($window->getKeyState(GLFW_KEY_W) === GLFW_PRESS) {
        $camera->moveForward(1.0);
    } elseif ($window->getKeyState(GLFW_KEY_S) === GLFW_PRESS) {
        $camera->moveBackward(1.0);
    }

    if ($window->getKeyState(GLFW_KEY_A) === GLFW_PRESS) {
        $camera->moveLeft(1.0);
    } elseif ($window->getKeyState(GLFW_KEY_D) === GLFW_PRESS) {
        $camera->moveRight(1.0);
    }

    glfwGetCursorPos($window->getContext(), $x, $y);
    $offx = ($x - $lx) * 0.2;
    $offy = ($y - $ly) * -0.2;

    //echo "$x, $y = $offx, $offy\n";

    $camera->updateAngel($offx, $offy);
    $lx = $x; $ly = $y;

    //$camera->printDebug();

    $gun->position = clone $camera->position;
    // $gun->position->z += sin(\glm\radians($camera->yaw));
    // $gun->position->x += cos(\glm\radians($camera->yaw));
    $gun->position->y -= 5;
    $gun->position = \glm\vec3(
        $gun->position->x + $camera->frontVector->x * 10,
        $gun->position->y + $camera->frontVector->y * 5,
        $gun->position->z + $camera->frontVector->z * -10
    );

    $gun->rotation->y = $camera->yaw + 90;
    $gun->__transformDirty = true;

    $gun2->rotation->y += 1;
    $gun2->__transformDirty = true;

    $scene->update();

    $window->clearColor(0.7, 0.7, 0.7, 1);
    $window->clear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    $scene->draw();

    // swap
    $window->swapBuffers();
}

